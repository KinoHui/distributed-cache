# 分布式缓存系统面试指南

## 项目概述

**项目名称**：分布式缓存系统  
**开发时间**：2025.02 - 2025.03  
**技术栈**：Go、LRU缓存淘汰算法、RESTful API、HTTP服务端、一致性哈希算法、Singleflight机制、Protobuf

## 核心架构

### 系统组件
- **LRU缓存模块**：基于双向链表+哈希表实现
- **一致性哈希**：分布式节点选择和数据路由
- **Singleflight机制**：防止缓存击穿
- **HTTP通信层**：节点间通信和API服务
- **Protobuf序列化**：高效数据传输

### 架构特点
- 支持多节点分布式部署
- 每个节点既是服务端又是客户端
- 基于Group概念进行数据分组管理
- 最终一致性模型

## 核心技术问题

### 1. LRU缓存淘汰算法

#### 增操作流程
```go
func (c *Cache) Add(key string, value Value) {
    if ele, ok := c.cache[key]; ok {
        // key已存在：更新value并移到头部
        c.ll.MoveToFront(ele)
        kv := ele.Value.(*entry)
        c.nbytes += int64(value.Len()) - int64(kv.value.Len())
        kv.value = value
    } else {
        // key不存在：创建新节点
        ele := c.ll.PushFront(&entry{key, value})
        c.cache[key] = ele
        c.nbytes += int64(len(key)) + int64(value.Len())
    }
    // 检查内存限制，必要时淘汰
    for c.maxBytes != 0 && c.maxBytes < c.nbytes {
        c.RemoveOldest()
    }
}
```

#### 查操作流程
```go
func (c *Cache) Get(key string) (value Value, ok bool) {
    if ele, ok := c.cache[key]; ok {
        c.ll.MoveToFront(ele)  // 移到链表头部
        kv := ele.Value.(*entry)
        return kv.value, true
    }
    return
}
```

**时间复杂度**：O(1)  
**空间复杂度**：O(n)  
**并发控制**：使用sync.Mutex保证线程安全

### 2. 冷热数据问题

**问题**：纯LRU算法中，冷数据访问一次后可能挤走热数据

**解决方案**：
- **LFU算法**：记录访问频率，优先淘汰低频数据
- **LRU-K**：记录最近K次访问时间，只有访问K次以上才认为是热数据
- **采样LRU**：Redis使用，随机采样后淘汰最旧的
- **热数据识别**：添加访问计数器，定期清理低频数据

### 3. 过期时间设计

**当前状态**：项目没有过期机制

**设计方案**：
```go
type entry struct {
    key       string
    value     Value
    expireAt  int64  // 过期时间戳
}

// 过期检查
func (c *Cache) Get(key string) (value Value, ok bool) {
    if ele, ok := c.cache[key]; ok {
        kv := ele.Value.(*entry)
        if kv.expireAt > 0 && time.Now().Unix() > kv.expireAt {
            c.removeElement(ele)
            return
        }
        c.ll.MoveToFront(ele)
        return kv.value, true
    }
    return
}
```

**清理策略**：
- 惰性删除：访问时检查过期
- 定期清理：后台定时扫描过期数据
- 内存压力时优先清理过期数据

### 4. 支持的数据结构

**当前支持**：
- 任意实现了`Value`接口的数据类型
- `ByteView`包装`[]byte`，支持任意二进制数据

```go
type Value interface {
    Len() int
}

type ByteView struct {
    b []byte
}
```

**实际应用**：
- 字符串、JSON、序列化对象
- 图片、文件等二进制数据
- 通过序列化支持复杂数据结构

### 5. 缓存失效处理流程

```go
func (g *Group) Get(key string) (ByteView, error) {
    // 1. 本地缓存查找
    if v, ok := g.mainCache.get(key); ok {
        return v, nil  // 缓存命中
    }
    
    // 2. 缓存未命中，触发加载
    return g.load(key)
}

func (g *Group) load(key string) (value ByteView, err error) {
    // 3. Singleflight防止重复请求
    viewi, err := g.loader.Do(key, func() (interface{}, error) {
        // 4. 尝试远程节点获取
        if g.peers != nil {
            if peer, ok := g.peers.PickPeer(key); ok {
                if value, err = g.getFromPeer(peer, key); err == nil {
                    return value, nil
                }
            }
        }
        // 5. 本地数据源获取
        return g.getLocally(key)
    })
    
    if err == nil {
        return viewi.(ByteView), nil
    }
    return
}
```

**处理策略**：
- 缓存命中：直接返回
- 缓存未命中：远程节点 → 本地数据源
- Singleflight：防止缓存击穿
- 错误处理：返回具体错误，不缓存失败结果

## 分布式架构

### 节点管理

#### 增加节点处理
```go
func (p *HTTPPool) Set(peers ...string) {
    p.mu.Lock()
    defer p.mu.Unlock()
    
    // 重新构建一致性哈希环
    p.peers = consistenthash.New(defaultReplicas, nil)
    p.peers.Add(peers...)
    
    // 创建HTTP客户端连接
    p.httpGetters = make(map[string]*httpGetter, len(peers))
    for _, peer := range peers {
        p.httpGetters[peer] = &httpGetter{baseURL: peer + p.basePath}
    }
}
```

#### 删除节点处理
- 当前项目：重新调用Set()方法，传入新节点列表
- 数据迁移：渐进式，按需迁移
- 影响范围：约1/N的数据需要重新路由

### 一致性哈希算法

```go
func (m *Map) Add(keys ...string) {
    for _, key := range keys {
        // 为每个真实节点创建虚拟节点
        for i := 0; i < m.replicas; i++ {
            hash := int(m.hash([]byte(strconv.Itoa(i) + key)))
            m.keys = append(m.keys, hash)
            m.hashMap[hash] = key
        }
    }
    sort.Ints(m.keys)  // 排序哈希环
}
```

**特点**：
- 使用CRC32哈希函数
- 默认50个虚拟节点
- 顺时针查找第一个大于等于key哈希值的节点
- 节点增减时减少数据迁移量

### Singleflight机制

```go
func (g *Group) Do(key string, fn func() (interface{}, error)) (interface{}, error) {
    g.mu.Lock()
    if c, ok := g.m[key]; ok {
        g.mu.Unlock()
        c.wg.Wait()  // 等待正在进行的请求
        return c.val, c.err
    }
    
    c := new(call)
    c.wg.Add(1)
    g.m[key] = c
    g.mu.Unlock()
    
    c.val, c.err = fn()  // 执行请求
    c.wg.Done()
    
    g.mu.Lock()
    delete(g.m, key)  // 清理
    g.mu.Unlock()
    
    return c.val, c.err
}
```

**作用**：
- 防止缓存击穿
- 减少重复请求
- 提高系统稳定性

## 持久化设计

### 当前状况
**没有持久化设计**，纯内存缓存系统

**原因**：
- 定位为缓存层，不是存储层
- 数据持久化由后端数据库负责
- 专注于缓存核心功能和性能

### 持久化方案（如需实现）

#### RDB快照方式
```go
type RDBPersistence struct {
    filePath string
    interval time.Duration
}

func (p *RDBPersistence) SaveSnapshot(cache *Cache) error {
    data := make(map[string][]byte)
    for key, value := range cache.cache {
        kv := value.Value.(*entry)
        data[key] = kv.value.([]byte)
    }
    
    file, err := os.Create(p.filePath)
    if err != nil {
        return err
    }
    defer file.Close()
    
    return json.NewEncoder(file).Encode(data)
}
```

#### AOF日志方式
```go
type AOFPersistence struct {
    file *os.File
    mu   sync.Mutex
}

func (p *AOFPersistence) AppendLog(operation string, key string, value []byte) {
    p.mu.Lock()
    defer p.mu.Unlock()
    
    log := fmt.Sprintf("%s %s %s\n", operation, key, string(value))
    p.file.WriteString(log)
    p.file.Sync()  // 强制刷盘
}
```

## 性能优化

### 优化措施
1. **LRU缓存**：减少数据库访问
2. **Singleflight**：避免重复请求
3. **一致性哈希**：减少数据迁移
4. **Protobuf序列化**：提高传输效率
5. **并发控制**：细粒度锁减少竞争

### 监控指标
- 缓存命中率
- 响应时间
- QPS
- 节点健康状态
- 内存使用情况

## 项目职责亮点

### 1. LRU模块设计
- 实现高效的O(1)时间复杂度缓存淘汰
- 使用双向链表+哈希表数据结构
- 支持内存限制和自动淘汰

### 2. 并发优化
- 通过细粒度锁保证线程安全
- Singleflight机制防止缓存击穿
- 支持高并发场景

### 3. 分布式协调
- 一致性哈希算法实现节点动态管理
- 支持节点增减时的平滑数据迁移
- HTTP协议实现节点间通信

### 4. 稳定性保障
- 多层容错机制
- 错误处理和降级策略
- 最终一致性模型

## 面试准备建议

### 1. 技术深度
- 理解LRU、一致性哈希等算法原理
- 熟悉Go并发编程模式
- 了解分布式系统设计原则

### 2. 架构思维
- 能够画出系统架构图和数据流程图
- 理解各组件间的交互关系
- 掌握性能优化的思路和方法

### 3. 扩展思考
- 如何支持数据持久化
- 如何实现高可用性
- 如何处理热点数据
- 如何监控和调优

### 4. 实际案例
- 准备项目中遇到的具体问题
- 说明解决方案和效果
- 展示问题分析和解决能力

## 可能的面试问题

### 基础问题
1. 解释LRU算法的实现原理
2. 一致性哈希解决了什么问题
3. Singleflight机制的作用是什么
4. 如何保证并发安全

### 进阶问题
1. 冷热数据问题如何解决
2. 如何设计过期时间机制
3. 节点增减时如何处理数据迁移
4. 如何实现高可用性

### 设计问题
1. 如何设计持久化机制
2. 如何处理热点数据
3. 如何监控系统性能
4. 如何扩展到更大规模

## 总结

这个分布式缓存系统项目体现了：
- **扎实的算法基础**：LRU、一致性哈希
- **并发编程能力**：锁机制、Singleflight
- **分布式系统理解**：节点管理、数据路由
- **性能优化意识**：缓存策略、通信优化
- **工程实践能力**：模块化设计、接口抽象

在面试中要突出技术深度、架构思维和解决问题的能力，展现对分布式系统的深入理解。